
import React, { useState, useEffect, useRef } from 'react';
import { Player, PlayerClass, Team } from '../types';
import { generateCommentary } from '../services/geminiService';
import { Button } from './Button';
import { GameHUD } from './GameHUD';
import { ScrapEngine } from './ScrapEngine';

interface MatchViewProps {
  playerTeam: Team;
  enemyTeamName: string;
  onMatchEnd: (won: boolean) => void;
}

type Vector = { x: number, y: number };

interface Entity {
  id: string;
  pos: Vector;
  vel: Vector;
  team: 'home' | 'away';
  role: PlayerClass;
  cooldowns: { turbo: number; shield: number; chaos: number; check: number; chirp: number };
  isStunned: number;
  isShielded: number; // New: Shield ability
  gameStats: { swagger: number; heat: number; trust: number; chemistry: number }; // New: Game stats
}

// Physics Constants - Tuned for slower gameplay
const PLAYER_ACCEL = 0.025;
const AI_ACCEL = 0.015;
const PUCK_FRICTION = 0.985;
const ICE_FRICTION = 0.92; // Higher drag to slow players down
const SHOOT_FORCE = 1.8;
const MAX_SPEED = 0.8; // Cap maximum speed

export const MatchView: React.FC<MatchViewProps> = ({ playerTeam, enemyTeamName, onMatchEnd }) => {
  const [score, setScore] = useState({ home: 0, away: 0 });
  const [time, setTime] = useState(180);
  const [commentary, setCommentary] = useState("Use ARROWS to Move, SPACE to Shoot!");
  const [gameEntities, setGameEntities] = useState<Entity[]>([]);
  const [isScrapActive, setIsScrapActive] = useState(false);
  const [scrapEnforcer1, setScrapEnforcer1] = useState<string>('');
  const [scrapEnforcer2, setScrapEnforcer2] = useState<string>('');

  // Game State Refs (for loop performance)
  const entitiesRef = useRef<Entity[]>([]);
  const puckRef = useRef<Vector>({ x: 50, y: 50 });
  const puckVelRef = useRef<Vector>({ x: 0, y: 0 });
  const puckOwnerRef = useRef<string | null>(null);
  const scrapCooldownRef = useRef<number>(0);

  const keysRef = useRef<Set<string>>(new Set());
  const requestRef = useRef<number>(0);
  const lastTimeRef = useRef<number>(0);
  const userCooldownsRef = useRef({ turbo: 0, shield: 0, chaos: 0 });
  const passCooldownRef = useRef<number>(0);

  // Initialize
  useEffect(() => {
    const starters = playerTeam.roster.slice(0, 3);
    
    const initialEntities: Entity[] = [
      ...starters.map((p, i) => ({
        id: p.id,
        pos: { x: 20, y: 30 + (i * 20) },
        vel: { x: 0, y: 0 },
        team: 'home' as const,
        role: p.class,
        cooldowns: { turbo: 0, shield: 0, chaos: 0, check: 0, chirp: 0 },
        isStunned: 0,
        isShielded: 0,
        gameStats: { ...p.gameStats } // Initialize gameStats from playerTeam
      })),
      { id: 'e1', pos: { x: 80, y: 30 }, vel: { x: 0, y: 0 }, team: 'away' as const, role: PlayerClass.SNIPER, cooldowns: { turbo: 0, shield: 0, chaos: 0, check: 0, chirp: 0 }, isStunned: 0, isShielded: 0, gameStats: { swagger: 0, heat: 0, trust: 0, chemistry: 0 } },
      { id: 'e2', pos: { x: 80, y: 50 }, vel: { x: 0, y: 0 }, team: 'away' as const, role: PlayerClass.ENFORCER, cooldowns: { turbo: 0, shield: 0, chaos: 0, check: 0, chirp: 0 }, isStunned: 0, isShielded: 0, gameStats: { swagger: 0, heat: 0, trust: 0, chemistry: 0 } },
      { id: 'e3', pos: { x: 80, y: 70 }, vel: { x: 0, y: 0 }, team: 'away' as const, role: PlayerClass.GOALIE, cooldowns: { turbo: 0, shield: 0, chaos: 0, check: 0, chirp: 0 }, isStunned: 0, isShielded: 0, gameStats: { swagger: 0, heat: 0, trust: 0, chemistry: 0 } },
    ];
    
    entitiesRef.current = initialEntities;
    setGameEntities(initialEntities);
    
    const handleKeyDown = (e: KeyboardEvent) => keysRef.current.add(e.code);
    const handleKeyUp = (e: KeyboardEvent) => keysRef.current.delete(e.code);
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
    };
  }, [playerTeam]);

  // Game Loop
  const update = (timestamp: number) => {
    if (!lastTimeRef.current) lastTimeRef.current = timestamp;
    lastTimeRef.current = timestamp;

    if (isScrapActive) {
      requestRef.current = requestAnimationFrame(update);
      return;
    }

    if (time <= 0) {
        cancelAnimationFrame(requestRef.current!);
        onMatchEnd(score.home > score.away);
        return;
    }

    // Decrement overall match time
    setTime(prev => Math.max(0, prev - (1/60))); // Assuming 60fps

    // 1. Process User Input (Controls the first home player)
    const userPlayer = entitiesRef.current.find(e => e.team === 'home' && playerTeam.roster.some(p => p.id === e.id));
    if (userPlayer && userPlayer.isStunned <= 0) {
        const playerSwagger = userPlayer.gameStats.swagger;
        const currentPLAYER_ACCEL = PLAYER_ACCEL * (1 + (playerSwagger / 100) * 0.5);

        // Movement
        if (keysRef.current.has('ArrowUp')) userPlayer.vel.y -= currentPLAYER_ACCEL;
        if (keysRef.current.has('ArrowDown')) userPlayer.vel.y += currentPLAYER_ACCEL;
        if (keysRef.current.has('ArrowLeft')) userPlayer.vel.x -= currentPLAYER_ACCEL;
        if (keysRef.current.has('ArrowRight')) userPlayer.vel.x += currentPLAYER_ACCEL;

        // Shooting / Passing
        if (keysRef.current.has('Space') && puckOwnerRef.current === userPlayer.id) {
             shootPuck(userPlayer);
             generateCommentary("He shoots!").then(setCommentary);
        }

        // Passing (P key)
        if (keysRef.current.has('KeyP') && puckOwnerRef.current === userPlayer.id && passCooldownRef.current <= 0) {
             passPuck(userPlayer);
             passCooldownRef.current = 30; // 0.5 second cooldown
        }

        // Abilities
        // Q: Turbo (1.5x speed, 2s duration, 5s cooldown)
        if (keysRef.current.has('KeyQ') && userCooldownsRef.current.turbo <= 0) {
            userPlayer.vel.x *= 1.5; 
            userPlayer.vel.y *= 1.5;
            userCooldownsRef.current.turbo = 300; // 5 seconds * 60 frames/sec
            generateCommentary("Turnin' on the jets!").then(setCommentary);
        }
        // W: Shield (Immunity, 1.5s duration, 8s cooldown)
        if (keysRef.current.has('KeyW') && userCooldownsRef.current.shield <= 0) {
            userPlayer.isShielded = 90; // 1.5 seconds * 60 frames/sec
            userCooldownsRef.current.shield = 480; // 8 seconds * 60 frames/sec
            generateCommentary("Shields up!").then(setCommentary);
        }
        // E: Chaos (Class-specific placeholder, 12s cooldown)
        if (keysRef.current.has('KeyE') && userCooldownsRef.current.chaos <= 0) {
            // Placeholder for class-specific Chaos ability
            generateCommentary("Chaos unleashed!").then(setCommentary);
            userCooldownsRef.current.chaos = 720; // 12 seconds * 60 frames/sec
        }
    }

    // 2. AI Logic & Physics for all entities
    entitiesRef.current.forEach(ent => {
        // Cooldowns / Stuns / Shields
        if (ent.isStunned > 0) ent.isStunned--;
        if (ent.isShielded > 0) ent.isShielded--;
        if (ent.cooldowns.turbo > 0) ent.cooldowns.turbo--;
        if (ent.cooldowns.shield > 0) ent.cooldowns.shield--;
        if (ent.cooldowns.chaos > 0) ent.cooldowns.chaos--;
        if (ent.cooldowns.check > 0) ent.cooldowns.check--;
        if (ent.cooldowns.chirp > 0) ent.cooldowns.chirp--;

        // Update user cooldowns for HUD
        if (ent.id === userPlayer?.id) {
          userCooldownsRef.current.turbo = ent.cooldowns.turbo;
          userCooldownsRef.current.shield = ent.cooldowns.shield;
          userCooldownsRef.current.chaos = ent.cooldowns.chaos;
        }

        if (ent.isStunned > 0) {
            ent.vel.x = 0; ent.vel.y = 0;
            return;
        }

        // AI Logic (skip user player)
        if (ent.id !== userPlayer?.id) {
            let target = { x: puckRef.current.x, y: puckRef.current.y };
            
            // Goalie Logic: Track puck at goal line
            if (ent.role === PlayerClass.GOALIE) {
                target = { x: ent.team === 'home' ? 5 : 95, y: puckRef.current.y };
                if (target.y < 35) target.y = 35;
                if (target.y > 65) target.y = 65;
            } 
            // Teammate Logic (if teammate has puck, move to net)
            else if (puckOwnerRef.current && entitiesRef.current.find(e => e.id === puckOwnerRef.current)?.team === ent.team) {
                target = { x: ent.team === 'home' ? 90 : 10, y: ent.pos.y }; // Move to net
            }
            // Opponent Logic: Pressure puck carrier
            else if (puckOwnerRef.current && entitiesRef.current.find(e => e.id === puckOwnerRef.current)?.team !== ent.team) {
                const puckOwner = entitiesRef.current.find(e => e.id === puckOwnerRef.current);
                if (puckOwner) target = { x: puckOwner.pos.x, y: puckOwner.pos.y };
            }

            // Sully Tilted (Heat > 70) - forces aggressive shooting
            if (ent.gameStats.heat > 70 && puckOwnerRef.current === ent.id) {
                const goalX = ent.team === 'home' ? 100 : 0;
                if (Math.random() < 0.05) { // 5% chance to shoot per frame
                    shootPuck(ent);
                    generateCommentary("Sully's TILTED! He's just firing pucks!").then(setCommentary);
                }
                target = { x: goalX, y: 50 }; // Force target to goal
            }

            // Move towards target
            const dx = target.x - ent.pos.x;
            const dy = target.y - ent.pos.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                ent.vel.x += (dx / dist) * AI_ACCEL;
                ent.vel.y += (dy / dist) * AI_ACCEL;
            }

            // AI Shooting
            if (puckOwnerRef.current === ent.id) {
                const goalX = ent.team === 'home' ? 100 : 0;
                if (Math.abs(ent.pos.x - goalX) < 40) {
                    if (Math.random() < 0.02) shootPuck(ent); // Slower shooting frequency
                }
            }
        }

        // Apply Friction
        ent.vel.x *= ICE_FRICTION;
        ent.vel.y *= ICE_FRICTION;

        // Clamp Speed
        const speed = Math.hypot(ent.vel.x, ent.vel.y);
        const maxSpeedWithSwagger = MAX_SPEED * (1 + (ent.gameStats.swagger / 100) * 0.5);
        if (speed > maxSpeedWithSwagger) {
            ent.vel.x = (ent.vel.x / speed) * maxSpeedWithSwagger;
            ent.vel.y = (ent.vel.y / speed) * maxSpeedWithSwagger;
        }

        // Apply Velocity
        ent.pos.x += ent.vel.x;
        ent.pos.y += ent.vel.y;

        // Wall collisions
        if (ent.pos.y < 2) { ent.pos.y = 2; ent.vel.y *= -0.5; }
        if (ent.pos.y > 98) { ent.pos.y = 98; ent.vel.y *= -0.5; }
        if (ent.pos.x < 0) { ent.pos.x = 0; ent.vel.x *= -0.5; }
        if (ent.pos.x > 100) { ent.pos.x = 100; ent.vel.x *= -0.5; }

        // Interactions with Puck
        const distToPuck = Math.hypot(ent.pos.x - puckRef.current.x, ent.pos.y - puckRef.current.y);
        
        // Take possession
        if (!puckOwnerRef.current && distToPuck < 3) {
            puckOwnerRef.current = ent.id;
        }
        
        // Steal possession?
        if (puckOwnerRef.current && puckOwnerRef.current !== ent.id && distToPuck < 3) {
             if (Math.random() < 0.02) { // Reduced steal chance
                 puckOwnerRef.current = ent.id;
                 generateCommentary("Turnover!").then(setCommentary);
             }
        }

        // Scrap detection on enforcer collision
        if (ent.role === PlayerClass.ENFORCER && ent.team === 'home' && scrapCooldownRef.current <= 0) {
          const otherEnforcers = entitiesRef.current.filter(e => e.role === PlayerClass.ENFORCER && e.team === 'away');
          for (const otherEnforcer of otherEnforcers) {
            const distBetweenEnforcers = Math.hypot(ent.pos.x - otherEnforcer.pos.x, ent.pos.y - otherEnforcer.pos.y);
            if (distBetweenEnforcers < 5) {
              setIsScrapActive(true);
              setScrapEnforcer1(playerTeam.roster.find(p => p.id === ent.id)?.name || 'Home Enforcer');
              setScrapEnforcer2(enemyTeamName + ' Enforcer'); // Generic name for enemy enforcer
              scrapCooldownRef.current = 600; // 10 seconds cooldown
              generateCommentary("A scrap has broken out!").then(setCommentary);
              break;
            }
          }
        }
    });

    // Decrement scrap cooldown
    if (scrapCooldownRef.current > 0) scrapCooldownRef.current--;

    // Decrement pass cooldown
    if (passCooldownRef.current > 0) passCooldownRef.current--;

    // 3. Puck Physics
    if (puckOwnerRef.current) {
        const owner = entitiesRef.current.find(e => e.id === puckOwnerRef.current);
        if (owner) {
            // Dribble: Stick puck slightly in front of velocity
            const offsetDist = 2;
            const angle = Math.atan2(owner.vel.y, owner.vel.x || (owner.team === 'home' ? 1 : -1));
            puckRef.current.x = owner.pos.x + Math.cos(angle) * offsetDist;
            puckRef.current.y = owner.pos.y + Math.sin(angle) * offsetDist;
            puckVelRef.current = { x: owner.vel.x, y: owner.vel.y };
        } else {
            puckOwnerRef.current = null; // Owner not found fallback
        }
    } else {
        // Free Puck
        puckRef.current.x += puckVelRef.current.x;
        puckRef.current.y += puckVelRef.current.y;
        puckVelRef.current.x *= PUCK_FRICTION;
        puckVelRef.current.y *= PUCK_FRICTION;

        // Puck Wall Bounces
        if (puckRef.current.y < 2 || puckRef.current.y > 98) puckVelRef.current.y *= -1;
        if (puckRef.current.x < 0 || puckRef.current.x > 100) puckVelRef.current.x *= -1;
    }

    // 4. Goal Check
    if (puckRef.current.x < 2 && Math.abs(puckRef.current.y - 50) < 10) {
        setScore(s => ({ ...s, away: s.away + 1 }));
        resetPositions();
        generateCommentary("They scored! 10-ply goaltending!").then(setCommentary);
        return;
    }
    if (puckRef.current.x > 98 && Math.abs(puckRef.current.y - 50) < 10) {
        setScore(s => ({ ...s, home: s.home + 1 }));
        resetPositions();
        generateCommentary("Bardownski! What a snipe!").then(setCommentary);
        return;
    }

    setGameEntities([...entitiesRef.current]); // Trigger re-render
    requestRef.current = requestAnimationFrame(update);
  };

  const shootPuck = (shooter: Entity) => {
      puckOwnerRef.current = null;
      // Shoot towards goal or in movement direction
      const goalX = shooter.team === 'home' ? 100 : 0;
      const goalY = 50;
      
      // Calculate angle to goal but add some randomness based on velocity
      let angle = Math.atan2(goalY - shooter.pos.y, goalX - shooter.pos.x);
      
      // Apply chemistry effect on shot angle randomness
      const chemistryEffect = (100 - shooter.gameStats.chemistry) / 100; // 0 to 1, lower chemistry = more randomness
      angle += (Math.random() - 0.5) * 0.2 * chemistryEffect;

      // If moving fast, bias towards movement direction
      if (Math.hypot(shooter.vel.x, shooter.vel.y) > 0.1) {
          const moveAngle = Math.atan2(shooter.vel.y, shooter.vel.x);
          angle = (angle + moveAngle) / 2;
      }

      puckVelRef.current = {
          x: Math.cos(angle) * SHOOT_FORCE,
          y: Math.sin(angle) * SHOOT_FORCE
      };
  };

  const resetPositions = () => {
    puckRef.current = { x: 50, y: 50 };
    puckVelRef.current = { x: 0, y: 0 };
    puckOwnerRef.current = null;
    
    // Reset players slightly and their gameStats
    entitiesRef.current.forEach((e, i) => {
         e.vel = { x: 0, y: 0 };
         e.isStunned = 0;
         e.isShielded = 0;
         e.gameStats = { swagger: 0, heat: 0, trust: 0, chemistry: 0 }; // Reset gameStats
         if (e.team === 'home') {
             e.pos = { x: 20, y: 30 + (i * 20) };
         } else {
             e.pos = { x: 80, y: 30 + ((i-3) * 20) };
         }
    });
  };

  useEffect(() => {
    requestRef.current = requestAnimationFrame(update);
    return () => cancelAnimationFrame(requestRef.current!); 
  }, [score, time, isScrapActive]); // Re-run effect if score or time changes

  const userPlayerForHUD = playerTeam.roster.find(p => p.id === entitiesRef.current.find(e => e.team === 'home' && playerTeam.roster.some(p => p.id === e.id))?.id);

  const handleScrapEnd = () => {
    setIsScrapActive(false);
    generateCommentary("The dust settles... for now.").then(setCommentary);
  };

  return (
    <div className="relative w-full h-full bg-gradient-to-b from-gray-800 to-gray-900 overflow-hidden">
      {/* Ice Rink */}
      <div className="absolute inset-0 bg-blue-200 opacity-20"></div>
      <div className="absolute inset-y-0 left-1/2 w-1 bg-white opacity-50"></div> {/* Center Line */}
      <div className="absolute inset-y-0 left-[5%] w-1 bg-red-500 opacity-50"></div> {/* Home Goal Line */}
      <div className="absolute inset-y-0 right-[5%] w-1 bg-red-500 opacity-50"></div> {/* Away Goal Line */}

      {/* Puck */}
      <div
        className="absolute w-2 h-2 rounded-full bg-black border border-gray-400"
        style={{
          left: `${puckRef.current.x}%`,
          top: `${puckRef.current.y}%`,
          transform: 'translate(-50%, -50%)',
        }}
      ></div>

      {/* Players */}
      {gameEntities.map(entity => (
        <div
          key={entity.id}
          className={`absolute w-4 h-4 rounded-full flex items-center justify-center font-bold text-xs
            ${entity.team === 'home' ? 'bg-blue-500 text-white' : 'bg-red-500 text-white'}
            ${entity.isStunned > 0 ? 'opacity-50 animate-pulse' : ''}
            ${entity.isShielded > 0 ? 'border-2 border-yellow-400' : ''}
          `}
          style={{
            left: `${entity.pos.x}%`,
            top: `${entity.pos.y}%`,
            transform: 'translate(-50%, -50%)',
          }}
        >
          {entity.role === PlayerClass.SNIPER && 'S'}
          {entity.role === PlayerClass.ENFORCER && 'E'}
          {entity.role === PlayerClass.PLAYMAKER && 'P'}
          {entity.role === PlayerClass.GOALIE && 'G'}
        </div>
      ))}

      {userPlayerForHUD && (
        <GameHUD
          player={userPlayerForHUD}
          score={score}
          time={time}
          commentary={commentary}
          cooldowns={userCooldownsRef.current}
        />
      )}

      {isScrapActive && (
        <ScrapEngine
          enforcer1Name={scrapEnforcer1}
          enforcer2Name={scrapEnforcer2}
          onScrapEnd={handleScrapEnd}
        />
      )}

      {/* Game Over Overlay */}
      {time === 0 && (
        <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-40">
          <div className="text-center">
            <h2 className="text-6xl font-black text-white mb-4">
              {score.home > score.away ? 'VICTORY!' : 'DEFEAT!'}
            </h2>
            <Button onClick={() => onMatchEnd(score.home > score.away)}>
              Continue
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};
